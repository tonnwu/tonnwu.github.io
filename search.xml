<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树的递归</title>
    <url>/2020/12/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="二叉树的递归"><a href="#二叉树的递归" class="headerlink" title="二叉树的递归"></a>二叉树的递归</h1><p>可以解决面试中绝大多数的二叉树问题尤其是树型dp问题</p>
<p>本质是利用递归遍历二叉树的便利性</p>
<p>通过题去熟悉套路！  数学题</p>
<a id="more"></a>

<h2 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h2><p>1）假设以X节点为头，假设可以向X左树和X右树要任何信息<br>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）    常见分类： 与x无关，与x有关</p>
<p>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息<br>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S<br>5）递归函数都返回S，每一棵子树都这么要求<br>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</p>
<p>​    难点：</p>
<p>​    1、假设分类</p>
<p>​    2、具体的可能性，需要什么具体信息</p>
<p>​    3、如何实现递归函数</p>
<p>​        1、base case<br>        2、递归左右树<br>​        3、加工该次如何返回要求信息</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1、isBalance"><a href="#1、isBalance" class="headerlink" title="1、isBalance"></a>1、isBalance</h3><p>​    给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树</p>
<p>​        1、列举全部可能</p>
<p>​            1、） 左树</p>
<p>​                树高</p>
<p>​                是否为平衡二叉树</p>
<p>​            2、）右树</p>
<p>​                树高</p>
<p>​                是否为平衡二叉树</p>
<p>​        2、需要信息就是树高，和是否为平衡二叉树（画递归树）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">   <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//树高为0</span></span><br><span class="line">   &#125;</span><br><span class="line">       <span class="comment">//递归</span></span><br><span class="line">Info(x.left);</span><br><span class="line">Info(x.right);</span><br><span class="line">       <span class="comment">//处理该次的信息返回</span></span><br><span class="line">height = max(左树高，右树高) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(左树.isAK </span><br><span class="line">	&amp;&amp; 右树.isAK </span><br><span class="line">	&amp;&amp; abs(左树.height - 右树.height)&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">       Info(x).isAk = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、is满二叉树"><a href="#2、is满二叉树" class="headerlink" title="2、is满二叉树"></a>2、is满二叉树</h3><p>​        给出一个head，返回这颗树是否是满二叉树</p>
<p>​        method1、暴力解法</p>
<p>​            1、找到树高height </p>
<p>​            2、遍历树节点个数nodes</p>
<p>​            3、 if(  nodes ==  (1&gt;&gt;height - 1))    yes   else  no</p>
<p>​        method2、树递归</p>
<p>举例所有的可能性：</p>
<p>​        1、head左、右子树，</p>
<p>​                树高 ， 节点数</p>
<p>​    所以info为树高、节点数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Info  <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="comment">//base case</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">new</span> Info(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">process(head.left);</span><br><span class="line">process(head.right);</span><br><span class="line"><span class="comment">//处理此次的信息</span></span><br><span class="line"><span class="keyword">int</span> height  = max(process(head.left).height ,</span><br><span class="line">process(head.right).height ) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nodes = process(head(left).nodes</span><br><span class="line">+process(head(right).nodes+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">new</span>  Info(height  ,nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">	process(head);</span><br><span class="line">	<span class="keyword">if</span>(  nodes ==  (<span class="number">1</span>&gt;&gt;height  - <span class="number">1</span>))    </span><br><span class="line">	yes   <span class="keyword">else</span>  no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、is完全二叉树"><a href="#3、is完全二叉树" class="headerlink" title="3、is完全二叉树"></a>3、is完全二叉树</h3><h4 id="method1、暴力解法"><a href="#method1、暴力解法" class="headerlink" title="method1、暴力解法"></a>method1、暴力解法</h4><p>​    情况1、有右孩子没有左孩子</p>
<p>​            2、有左右孩子不双全，后序又出现孩子的情况！    </p>
<p>​            其余情况都是满足条件</p>
<p>​            使用宽度优先遍历，之后使用flag1记录左右孩子不双全的情况,出现情况1、2就退出！</p>
<h4 id="method2、树递归方法"><a href="#method2、树递归方法" class="headerlink" title="method2、树递归方法"></a>method2、树递归方法</h4><p>​    举例所有答案</p>
<p>​        1、）满二叉树</p>
<p>​        2、）有缺口</p>
<p>​            1：左树没有撑满，右树为满二叉树</p>
<p>​            2：左树撑满，但是没有到右树，左右树都是满二叉树</p>
<p>​            3：左树撑满，右树为完全二叉树</p>
<p>​        转为数学表达式：</p>
<p>​            2.1     left.height  - right.height =  1 </p>
<p>​                        左.isCBT(完全)    右.isFull(满） </p>
<p>​            <strong>可能会需要的信息： 树的结点数，用于判断isFull。但是没有必要，因为，当左树，右树都是full，且高度差为0，该树必定为满二叉树。base case 时，full 为 true。所以之前的题可以用这个思想去优化！！！</strong></p>
<p>​        同理2.2   ,2.3都需要上述的height,isFull,isCBT的三个信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> isFull; <span class="comment">//满</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> isCBT; <span class="comment">//完全</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> height; <span class="comment">//高度</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> full, <span class="keyword">boolean</span> cbt, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">			isFull = full;</span><br><span class="line">			isCBT = cbt;</span><br><span class="line">			height = h;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Info  <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="comment">//base case</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span>  </span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//递归</span></span><br><span class="line">		Info leftInfo = process(head.left);</span><br><span class="line">		Info rightInfo = process(head.right);</span><br><span class="line">		<span class="comment">//处理次次消息</span></span><br><span class="line">		<span class="keyword">int</span> height = max(leftInfo.height ,</span><br><span class="line">		rightInfo.height ) + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> isFull =<span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(leftInfo.isFull</span><br><span class="line">        &amp;&amp;</span><br><span class="line">		rightInfo.isFull</span><br><span class="line">		&amp;&amp;</span><br><span class="line">		leftInfo.height</span><br><span class="line">        == </span><br><span class="line">       rightInfo.height)&#123; isFull = <span class="keyword">true</span>;&#125;</span><br><span class="line">		</span><br><span class="line">		isCBT = <span class="keyword">false</span> ;</span><br><span class="line">		<span class="keyword">if</span>(isFull)&#123;</span><br><span class="line">			isCBT = <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line">		<span class="keyword">if</span>( leftInfo.isCBT </span><br><span class="line">		&amp;&amp;  </span><br><span class="line">		rightInfo.isFull</span><br><span class="line">		&amp;&amp;</span><br><span class="line">		leftInfo.height -	</span><br><span class="line">		rightInfo.height ==  <span class="number">1</span>)&#123;isCBT = <span class="keyword">true</span>;&#125;</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">		<span class="keyword">if</span>(leftInfo.isFull</span><br><span class="line">		&amp;&amp;  </span><br><span class="line">		rightInfo.isFull</span><br><span class="line">		&amp;&amp;</span><br><span class="line">		leftInfo.height -	</span><br><span class="line">		rightInfo.height ==  <span class="number">1</span>)&#123;isCBT = <span class="keyword">true</span>;&#125;</span><br><span class="line">		<span class="comment">//3</span></span><br><span class="line">		<span class="keyword">if</span>(leftInfo.isFull</span><br><span class="line">		&amp;&amp;  </span><br><span class="line">		rightInfo.isCBT</span><br><span class="line">		&amp;&amp;</span><br><span class="line">		leftInfo.height -	</span><br><span class="line">		rightInfo.height ==  <span class="number">0</span>&#123;isCBT = <span class="keyword">true</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Info(isFull, isCBT, height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、返回最大距离"><a href="#4、返回最大距离" class="headerlink" title="4、返回最大距离"></a>4、返回最大距离</h3><p>​    给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离</p>
<p>1、）最大距离 列举答案所有可能假设分类：</p>
<p>​        1、与head无关</p>
<p>​                需要左最大距离，左max</p>
<p>​                需要右最大距离，右max</p>
<p>​                最大距离 =  （左max，右max）</p>
<p>​        2、与head有关 </p>
<p>​                换言之就是俩棵最深树的距离</p>
<p>​                最大距离 = 左树高+1+右树高  </p>
<p>​                树高 = max(左数高 ，右树高) + 1 </p>
<p>3种情况</p>
<p>2、）需要信息</p>
<p>​        1、树的高度</p>
<p>​        2、点的最大距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Info <span class="title">process</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> Info( <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">	Info(x.left);</span><br><span class="line">	Info(x.right);</span><br><span class="line">    <span class="comment">//处理本次的信息sf</span></span><br><span class="line">    </span><br><span class="line">	height = max(左树高，右树高) + <span class="number">1</span>;</span><br><span class="line">    distance = 左树高 + 右树高 + <span class="number">1</span> ;</span><br><span class="line">	maxDistance = max(distance,max(Info(x.left).maxDistance,Info(x.right).maxDistance))</span><br><span class="line">       <span class="keyword">return</span>  <span class="keyword">new</span> Info(height , maxDistance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>剩下的举例见算法题！</p>
<h3 id="5、公共父节点"><a href="#5、公共父节点" class="headerlink" title="5、公共父节点"></a>5、公共父节点</h3><p>​        给定一棵二叉树的头节点head，和另外两个节点o1和o2。返回o1和o2的最低公共祖先</p>
<p>​    method1、暴力解</p>
<p>​    1、使用map记录每个键值对&lt;子节点，父节点&gt;</p>
<p>​    2、使用set，将a的节点的所有父节点加入set</p>
<p>​    3、遍历b的父节点，set.contain(b.父节点)  判断是否有重复</p>
<p>​    method2、二叉树递归</p>
<p>​    分析所有答案情况：   </p>
<p>​    1、 o1,o2不在head</p>
<p>​    2、 o1,o2有一个在head的子树上  （都没有交汇）</p>
<p>​    3、o1,o2都在head的子树上   （必有交汇点）</p>
<p>​            1）全在左子树</p>
<p>​            2）全在右子树</p>
<p>​            3）左右个一个</p>
<p>​            4）o1 or o2为head </p>
<p>需要的信息：</p>
<p>树上有无o1,o2,交汇点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">   <span class="comment">//第一个交会的父节点</span></span><br><span class="line">   <span class="keyword">public</span> Node ans;</span><br><span class="line">   <span class="comment">//发现01</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> findO1;</span><br><span class="line">   <span class="comment">//发现02</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> findO2;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(Node a, <span class="keyword">boolean</span> f1, <span class="keyword">boolean</span> f2)</span> </span>&#123;</span><br><span class="line">      ans = a;</span><br><span class="line">      findO1 = f1;</span><br><span class="line">      findO2 = f2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span>(head  == <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">null</span>,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		Info leftInfo = process(head.left);</span><br><span class="line">		Info rightInfo = process(head.right);</span><br><span class="line">	<span class="comment">//3信息</span></span><br><span class="line">		<span class="keyword">boolean</span> findO1 = head == o1 || leftInfo.findO1 || rightInfo.findO1;</span><br><span class="line">		<span class="keyword">boolean</span> findO2 = head == o2 || leftInfo.findO2 || rightInfo.findO2;</span><br><span class="line">	<span class="comment">//3信息整合才是上述简要概括</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java后端</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法总结</title>
    <url>/2020/12/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1 选择排序"></a>1 选择排序</h3><p><strong>步骤</strong>: </p>
<p>1在序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<p>2 从剩余序列中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>3 重复第二步，直到所有元素均排序完毕。</p>
<a id="more"></a>

<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p>
<p>时间复杂度：O(n^2)</p>
<p>额外空间复杂度：O(1)</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 0～n-1</span></span><br><span class="line">		<span class="comment">// 1～n-1</span></span><br><span class="line">		<span class="comment">// 2～n-1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// i ~ N-1</span></span><br><span class="line">			<span class="comment">// 最小值在哪个位置上  i～n-1</span></span><br><span class="line">			<span class="keyword">int</span> minIndex = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// i ~ N-1 上找最小值的下标 </span></span><br><span class="line">				minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(arr, i, minIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h3><p><strong>步骤</strong>: </p>
<p>1 从头开始比较相邻的两个元素，小的数字放到前面的位置(一轮结束后已经确定出最大的数)</p>
<p>2 重复上一步骤直到达到已排序数的位置</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p>
<p>时间复杂度：O(n^2)</p>
<p>额外空间复杂度：O(1)</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123; <span class="comment">// 0 ~ e</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">					swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h3><p><strong>步骤</strong>: </p>
<p>1 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>2 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。保证稳定性）</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p>
<p>时间复杂度：O(n^2)</p>
<p>额外空间复杂度：O(1)</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 0~0 有序的</span></span><br><span class="line">		<span class="comment">// 0~i 想有序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 0 ~ i 做到有序</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// arr[i]往前看，一直交换到合适的位置停止</span></span><br><span class="line">			<span class="comment">// ...(&lt;=)  ?       &lt;- i</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">				swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4 归并排序"></a>4 归并排序</h3><p><strong>排序步骤</strong>: </p>
<p>1 把无序数组从中间分为成两部分(左组和右组)</p>
<p>2 左组和右组分别排好序(使用递归)</p>
<p>3 合并左组和右组</p>
<p><strong>合并步骤</strong>:</p>
<p>1 使用两个指针分别指向左右组的第一个数</p>
<p>2 比较两个指针所指的数字：2.1 <strong>左</strong>指针所指的<strong>数</strong>小于等于<strong>右</strong>指针所指的<strong>数</strong>,  拷贝左边的数到help数组，左指针加一；2.2 <strong>左</strong>指针所指的<strong>数</strong>大于<strong>右</strong>指针所指的<strong>数</strong>,  拷贝右边的数到help数组，右指针加一。 直到某一边的指针到达该分组的右边界</p>
<p>3 直接将剩余未比较的数拷贝的help数组</p>
<p>特点:  涉及比较、统计某一个数的左右两边数的分布，可以使用归并排序的思路：比如，<strong>求小和问题</strong>、<strong>逆序对问题</strong>。</p>
<p>时间复杂度：O(n*log(n))</p>
<p>额外空间复杂度：O(n)</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//给help使用的 </span></span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123; <span class="comment">// p1 和p2都不越界的时候，拷贝数组</span></span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]; <span class="comment">// 拷贝哪边，哪边的指针就加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		以下两个一定只会发生一个</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">//base case 最小的规模，不需要调用； </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-随机快排"><a href="#5-随机快排" class="headerlink" title="5 随机快排"></a>5 随机快排</h3><blockquote>
<p>以下描述中 默认L为待排序的数组的左边界，R为待排序的数组的左边界</p>
<p>小于区右边界： 序号在右边界之前的(<strong>包括边界</strong>)的数均小于num</p>
<p>大于区左边界： 序号在左边界之后的(<strong>不包括边界</strong>)的数均大于num</p>
</blockquote>
<p><strong>partition问题</strong>:  把一列数arr按照最右边的数num分区，左边都是小于num的数，右边都是大于等于num的数。要求额外空间复杂度O(1)，时间复杂度O(N)</p>
<p>partition步骤：</p>
<p>1 初始化参数，小于区的右边界序号为L - 1。</p>
<p>2  从左往右遍历每个数(直到倒数第二个)，与num比较：2.1 小于等于num， 与小于区<strong>右边界的右一个</strong>交换位置，小于区的右边界序号**+1<strong>；2.2 大于num，小于区的右边界序号</strong>不变**。</p>
<p>3  将最右边的数(既是用来比较那个数num)与小于区<strong>右边界的右一个</strong>交换位置。</p>
<p><strong>荷兰国旗问题</strong>： 给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等<br>于num的数放在中间，大于num的数放在数组的右边。</p>
<p>荷兰国旗问题步骤：</p>
<p>1 初始化参数，小于区的右边界序号为L - 1，大于区的左边界序号为R。</p>
<p>2  从左往右遍历每个数(直到倒数第二个)，与num比较：2.1 小于num， 与小于区<strong>右边界的右一个</strong>交换位置，小于区的右边界序号**+1<strong>，遍历序号</strong>+1<strong>；2.2 等于num，小于区的右边界序号</strong>不变<strong>，遍历序号</strong>+1** ；2.3 大于num，与大于区<strong>左边界的左一个</strong>交换位置，小于区的右边界序号<strong>不变</strong>，遍历序号<strong>不变</strong>，大于区左边界序号<strong>减1</strong>。</p>
<p>3  将最右边的数(既是用来比较那个数num)与小于区<strong>右边界的右一个</strong>交换位置。</p>
<p><strong>快排1.0</strong>：使用递归不断partition(返回小于等于区序号)，一次排好一个数</p>
<p><strong>快排2.0</strong>：使用递归不断解决荷兰国旗问题(返回等于区边界)，一次搞定一组相同的数的位置</p>
<p><strong>快排3.0</strong>：随机选择一个数作为比较的num，再按照快排2.0</p>
<blockquote>
<p>如果选择的数好，每次递归都是从中间分，这样的时间复杂度能达到o(n*log(n))。最坏的情况下 时间复杂度是o(n^2). 引入随机性抵消最坏的情况出现的可能性，推算出来的平均复杂度是O(n*log(n))</p>
</blockquote>
<p>时间复杂度：O(n*log(n))</p>
<p>额外空间复杂度：O(log(n))</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lessEqual = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = L;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt;= arr[R]) &#123;</span><br><span class="line">            swap(arr, index, ++lessEqual);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, ++lessEqual, R);</span><br><span class="line">    <span class="keyword">return</span> lessEqual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherlandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; L, R &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>; <span class="comment">// 小于区域的右边界</span></span><br><span class="line">    <span class="keyword">int</span> more = R;  <span class="comment">// 大于区域的左边界</span></span><br><span class="line">    <span class="keyword">int</span> index = L;  <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">            swap(arr, index++, ++less); <span class="comment">// 当前区域与小于区域的右一个做交换，跳下一个，小于区域右移</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr, index, --more);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L...Less  Less...more -1 more...R-1 R</span></span><br><span class="line">    swap(arr, more, R);  <span class="comment">// 将右边界与大于区域第一个数交换，原因是整个过程中右边界没有移动过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排1.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L..R partition arr[R]  ===&gt;  [&gt;arr[R] arr[R] &gt;arr[R]]</span></span><br><span class="line">    <span class="comment">// 一次递归只解决一个数的位置</span></span><br><span class="line">    <span class="keyword">int</span> M = partition(arr, L, R);</span><br><span class="line">    process1(arr, L, M - <span class="number">1</span>);</span><br><span class="line">    process1(arr, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排2.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比partition的优点是一次搞定一组相同的数的位置</span></span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">    process1(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process1(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排3.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process3(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R); <span class="comment">// 随机选择一个数</span></span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">    process3(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process3(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6 堆排序"></a>6 堆排序</h3><blockquote>
<p>堆结构比堆排序重要</p>
</blockquote>
<p>大根堆：每一棵树<strong>最大</strong>的数都是头节点</p>
<p>小根堆：每一棵树<strong>最小</strong>的数都是头节点</p>
<p><strong>建立大根堆的步骤</strong>(数组实现堆)：</p>
<p>HeapInsert:   新增节点，依旧保存大根堆</p>
<p>1  每新加一个数都向上与他的父节点比较</p>
<p>2  比父节点大与父节点交换位置，继续向上比较</p>
<p>3  直到比父节点小就停止比较</p>
<p>HeapIfy：弹出父节点依旧保持是大根堆的方法</p>
<p>1  左右孩子比较谁大，下标给largest</p>
<p>2  孩子最大的与父比较，找到子夫最大的节点; 如果最大的依旧是父，则停止循环；是子则交换父子继续下沉</p>
<p><strong>堆排序：</strong></p>
<p>1   先让整个数组都变成大根堆结构</p>
<p>2   把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，<br>一直周而复始，时间复杂度为O(N*logN) </p>
<p>3  堆的大小减小成0之后，排序完成</p>
<p>时间复杂度：O(n*log(n))</p>
<p>额外空间复杂度：O(1)</p>
<p>示例： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 一直往上跑 与父节点比较</span></span><br><span class="line">			<span class="comment">// （0-1）/2为什么时自己？ ---&gt; index不可能为0 __20201123</span></span><br><span class="line">			<span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">				swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">				index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//从index位置往下看，不断下沉</span></span><br><span class="line">			<span class="comment">//停的条件：子都不比我大; 没有子</span></span><br><span class="line">			<span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 当有子的时候</span></span><br><span class="line">			    <span class="comment">// 左右两孩子，谁大下标给largest</span></span><br><span class="line">				<span class="comment">// 右胜出：1) 有右孩子 &amp;&amp; 2) 右孩子比左孩子大</span></span><br><span class="line">				<span class="comment">// or 左胜出</span></span><br><span class="line">				<span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">				<span class="comment">// 找到子父最大的下标，else后意味父是最大的 </span></span><br><span class="line">				largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">				<span class="comment">// 和三元运算符重复，但不能把index改成break</span></span><br><span class="line">				<span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				swap(arr, largest, index);</span><br><span class="line">				index = largest;</span><br><span class="line">				left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// O(N*logN) 从下往上</span></span><br><span class="line"><span class="comment">//		for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span></span><br><span class="line"><span class="comment">//			heapInsert(arr, i); // O(logN)</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">        <span class="comment">// 以下为优化的堆排序，O(N)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			heapify(arr, i, arr.length);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">		swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">		<span class="comment">// O(N*logN)</span></span><br><span class="line">		<span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123; <span class="comment">// O(N)</span></span><br><span class="line">			heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">			swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-计数排序"><a href="#7-计数排序" class="headerlink" title="7 计数排序"></a>7 计数排序</h3><blockquote>
<p>一般来讲，计数排序要求，样本是整数，且范围比较窄</p>
</blockquote>
<p>步骤： </p>
<p>1 找到待排序所有数最大和最小数， 从小到大建立桶存放每个数出现次数</p>
<p>2  从桶中依次恢复数据</p>
<p>动图演示： </p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			max = Math.max(max, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			bucket[arr[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				arr[i++] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8 基数排序"></a>8 基数排序</h3><blockquote>
<p>一般来讲，基数排序要求，样本是10进制的正整数</p>
</blockquote>
<p>步骤：(常规方法) </p>
<p>1 如果是10进制就建立10个桶</p>
<p>2 从左到右观察数据的个位，按照桶的标号依次入桶</p>
<p>3 按照桶的位置(同桶先进先出)，再从左到右观察数据的十位</p>
<p>4 重复3 直到最高位</p>
<p>动图演示： </p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr[l..r]排序  ,  digit</span></span><br><span class="line"><span class="comment">// 没有准备10个桶(队列)，直接使用一个长度为10的数组实现基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有多少个数准备多少个辅助空间</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= digit; d++) &#123; <span class="comment">// 有多少位就进出几次</span></span><br><span class="line">        <span class="comment">// 10个空间</span></span><br><span class="line">        <span class="comment">// count[0] 当前位(d位)是0的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix]; <span class="comment">// count[0..9]</span></span><br><span class="line">        <span class="keyword">for</span> (i = L; i &lt;= R; i++) &#123;</span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            count[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) &#123;</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i = R; i &gt;= L; i--) &#123;</span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            help[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++) &#123;</span><br><span class="line">            arr[i] = help[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得指定位的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x / ((<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h3><p>1 排序算法的稳定性</p>
<p>稳定性是指同样大小的样本再排序之后不会改变相对次序<br>对基础类型来说，稳定性毫无意义<br>对非基础类型来说，稳定性有重要意义</p>
<p>2 排序算法总结</p>
<p><img src="https://raw.githubusercontent.com/tonnwu/PicGo/master/tonnweb/2020/12/sort.png" alt="image"></p>
<blockquote>
<p>1）不基于比较的排序，对样本数据有严格要求，不易改写<br>2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用<br>3）基于比较的排序，时间复杂度的极限是O(N*logN)<br>4）时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。<br>5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java后端</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表基础</title>
    <url>/2020/12/20/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="1-方法论"><a href="#1-方法论" class="headerlink" title="1 方法论"></a>1 方法论</h3><p>笔试：注重时间复杂度，可以不考虑空间复杂度</p>
<p>面试：一定要是时间复杂度最优的情况下空间也是最优的方法</p>
<h3 id="2-解链表题常用方法"><a href="#2-解链表题常用方法" class="headerlink" title="2 解链表题常用方法"></a>2 解链表题常用方法</h3><ul>
<li>借助常用数据结构(栈、队列、哈希表等)</li>
<li>:star:快慢指针</li>
</ul>
<blockquote>
<p>链表题目主要是考察coding能力</p>
</blockquote>
<a id="more"></a>

<h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3 例题"></a>3 例题</h3><h4 id="3-1-快慢指针"><a href="#3-1-快慢指针" class="headerlink" title="3.1 快慢指针"></a>3.1 快慢指针</h4><p><strong>题目：</strong></p>
<p><img src="https://raw.githubusercontent.com/tonnwu/PicGo/master/tonnweb/2020/10/image-20201209205032305.png" alt="image-20201209205032305"></p>
<p><img src="https://raw.githubusercontent.com/tonnwu/PicGo/master/tonnweb/2020/12/image-20201209213604015.png" alt="img"></p>
<p><strong>思路：</strong>快指针的速度比慢指针的速度快一倍，所以当快指针到链表末尾时，慢指针会到近似中点的位置</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 奇数返回中点，偶数返回上中点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node slow = head.next;</span><br><span class="line">		Node fast = head.next.next;</span><br><span class="line">		<span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			slow = slow.next;</span><br><span class="line">			fast = fast.next.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> slow;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> </p>
<ul>
<li><p>常用于其它链表题中求中间位置</p>
</li>
<li><p><font color='red'>如何通过我们需要找到的近似中点来确定初始条件</font>(例如奇数长度 -&gt; 中点下一个，偶数长度 -&gt; 下中点该如何设置初始条件？)</p>
</li>
</ul>
<h4 id="3-2-is回文链表"><a href="#3-2-is回文链表" class="headerlink" title="3.2  is回文链表"></a>3.2  is回文链表</h4><p><strong>题目：</strong></p>
<p>给定一个单链表的头节点head，请判断该链表是否为回文结构。</p>
<p><strong>思路：</strong></p>
<ul>
<li><p>栈方法：</p>
<blockquote>
<p>方法1： 遍历每个节点，储存到栈当中，然后依次弹出栈的元素与链从头遍历比较</p>
<p>(时间复杂度O(n),空间复杂度O(n) )</p>
</blockquote>
<blockquote>
<p> 方法2： 找到链表的中点(奇数长度 -&gt; 中点下一个，偶数长度 -&gt; 下中点)。从中点后开始遍历每个节点，储存到栈当中，然后依次弹出栈的元素与链从头遍历比较</p>
<p>(时间复杂度O(n),空间复杂度O(n/2) )</p>
</blockquote>
</li>
<li><p>不需要额外空间的方法</p>
<blockquote>
<p>找到链表的中点(<strong>奇数长度 -&gt; 中点下一个，偶数长度 -&gt; 下中点</strong>)，从中点后开始对每个一个节点进行逆序，直到末尾建立一个新头。然后同时从<strong>两端</strong>的头节点向<strong>中间</strong>开始遍历并依个比较。(时间复杂度O(n),空间复杂度O(1) )。<strong>注意结束后复原链表</strong></p>
</blockquote>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// need n extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need n/2 extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node right = head.next;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need O(1) extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n1 = head;</span><br><span class="line">    Node n2 = head;</span><br><span class="line">    <span class="keyword">while</span> (n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>) &#123; <span class="comment">// find mid node</span></span><br><span class="line">        n1 = n1.next; <span class="comment">// n1 -&gt; mid</span></span><br><span class="line">        n2 = n2.next.next; <span class="comment">// n2 -&gt; end</span></span><br><span class="line">    &#125;</span><br><span class="line">    n2 = n1.next; <span class="comment">// n2 -&gt; right part first node</span></span><br><span class="line">    n1.next = <span class="keyword">null</span>; <span class="comment">// mid.next -&gt; null</span></span><br><span class="line">    Node n3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="keyword">null</span>) &#123; <span class="comment">// right part convert</span></span><br><span class="line">        n3 = n2.next; <span class="comment">// n3 -&gt; save next node</span></span><br><span class="line">        n2.next = n1; <span class="comment">// next of right node convert</span></span><br><span class="line">        n1 = n2; <span class="comment">// n1 move</span></span><br><span class="line">        n2 = n3; <span class="comment">// n2 move</span></span><br><span class="line">    &#125;</span><br><span class="line">    n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">    n2 = head;<span class="comment">// n2 -&gt; left first node</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>) &#123; <span class="comment">// check palindrome</span></span><br><span class="line">        <span class="keyword">if</span> (n1.value != n2.value) &#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next; <span class="comment">// left to mid</span></span><br><span class="line">        n2 = n2.next; <span class="comment">// right to mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    n1 = n3.next;</span><br><span class="line">    n3.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span>) &#123; <span class="comment">// recover list</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = n3;</span><br><span class="line">        n3 = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-链表的partition"><a href="#3-3-链表的partition" class="headerlink" title="3.3  链表的partition"></a>3.3  链表的partition</h4><p><strong>题目：</strong></p>
<p>将单向链表按某值划分成左边小、中间相等、右边大的形式。</p>
<p><strong>思路：</strong></p>
<ul>
<li><p>把链表放入数组里，在数组上做partition（笔试用）</p>
<blockquote>
<p>partition见排序总结(时间复杂度O(n),空间复杂度O(n) )</p>
</blockquote>
</li>
<li><p>分成小、中、大三部分，再把各个部分之间串起来</p>
<p><img src="https://raw.githubusercontent.com/tonnwu/PicGo/master/tonnweb/2020/12/image-20201209213604015.png" alt="image-20201209213604015"></p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把链表装入数组中然后利用数组的partition方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++small, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nodeArr, --big, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">    Node mH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">    Node mT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">    Node next = <span class="keyword">null</span>; <span class="comment">// save next node</span></span><br><span class="line">    <span class="comment">// every node distributed to three lists</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mH = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mT.next = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// small and equal reconnect</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有小于区域</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT; <span class="comment">// 下一步，谁去连大于区域的头，谁就变成eT</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的if，不管跑了没有，et</span></span><br><span class="line">    <span class="comment">// all reconnect</span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果小于区域和等于区域，不是都没有</span></span><br><span class="line">        eT.next = mH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : (eH != <span class="keyword">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-克隆随机链表"><a href="#3-4-克隆随机链表" class="headerlink" title="3.4  克隆随机链表"></a>3.4  克隆随机链表</h4><p><strong>题目：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> Node next;</span><br><span class="line">	<span class="keyword">public</span> Node rand;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。<br><strong>思路：</strong></p>
<p>1 使用哈希图</p>
<blockquote>
<p>时间复杂度O(N)，额外空间复杂度O(N)</p>
</blockquote>
<p><img src="E:\program_data\Typora\Image\微信图片_20201210213958.jpg" alt="微信图片_20201210213958"></p>
<p>2 只使用链表</p>
<blockquote>
<p>时间复杂度O(N)，额外空间复杂度O(1)</p>
</blockquote>
<p><img src="E:\program_data\Typora\Image\微信图片_20201210214004.jpg" alt="微信图片_20201210214004"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cur 老</span></span><br><span class="line">        <span class="comment">// map.get(cur) 新</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// copy node and link to every node</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 2</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 1&#x27; -&gt; 2</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cur 老</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    Node curCopy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// set copy node rand</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cur 老</span></span><br><span class="line">        <span class="comment">// cur.next  新 copy</span></span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy.rand = cur.rand != <span class="keyword">null</span> ? cur.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node res = head.next;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// split</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-判断链表公共节点"><a href="#3-5-判断链表公共节点" class="headerlink" title="3.5 判断链表公共节点"></a>3.5 判断链表公共节点</h4><p><strong>问题：</strong> </p>
<p>给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null。要求：如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。</p>
<p><strong>思路：</strong></p>
<ul>
<li><p>分析两个链表可能出现的情况：</p>
<ul>
<li>两个都无环<ul>
<li>没有公共交点</li>
<li>有公共交点</li>
</ul>
</li>
<li>一个有环一个无环—–不可能相交</li>
<li>两个都有环<ul>
<li>没有公共节点</li>
<li>入环节点相同</li>
<li>入环节点不同</li>
</ul>
</li>
</ul>
</li>
<li><p>求无环链表的相交节点</p>
<blockquote>
<p> 从两个链表的头开始向后遍历，记录经历的节点数。当到达链表末端时，求出两个链表的长度差。然后长链表先走，直到剩下的长度与短链表相同。最后再同时遍历 逐个判断是否相等</p>
</blockquote>
</li>
<li><p>求入环节点的方法</p>
<blockquote>
<p>1 判断是否有环： 是否快慢指针观察是否相遇，记录相遇位置，不相遇返回<code>null</code></p>
<p>2 求入环节点： 建立新指针从头节点出发以及从相遇节点出发，再一次相遇的位置就是入环节点</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/5740965-68212411898859df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/771/format/webp" alt="img"></p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无环链表相交节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n1 慢  n2 快</span></span><br><span class="line">    Node n1 = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">    Node n2 = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n  :  链表1长度减去链表2长度的值</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// 谁长，谁的头变成cur1</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// 谁短，谁的头变成cur2</span></span><br><span class="line">    <span class="comment">// 长链表先走插值步</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>Java后端</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
